import 'dart:convert';
import 'dart:ui';

import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:insightme/Core/widgets/chart.dart';
import 'package:insightme/Prediction/wvc_chart.dart';

import 'color_scale.dart';
import 'core.dart';
import 'gantt.dart';

/// json_to_dart https://javiercbk.github.io/json_to_dart/
class PredictionAutogenerated {
  double prediction;
  double ci68;
  List<double> ci95;
  List<double> scaleBounds;
  double targetMean;

  PredictionAutogenerated(
      {this.prediction,
      this.ci68,
      this.ci95,
      this.scaleBounds,
      this.targetMean});

  PredictionAutogenerated.fromJson(Map<String, dynamic> json) {
    prediction = json['prediction'];
    ci68 = json['ci68'];
    ci95 = json['ci95'].cast<double>();
    scaleBounds = json['scale_bounds'].cast<double>();
    targetMean = json['target_mean'];
  }
}

class PredictionRoute extends StatefulWidget {
  @override
  State<PredictionRoute> createState() => _PredictionRouteState();
}

class _PredictionRouteState extends State<PredictionRoute> {
  @override
  Widget build(BuildContext context) {
    /// read files
    Future<PredictionAutogenerated> _readPhonePredictionIOFiles() async {
      String data = await DefaultAssetBundle.of(context)
          .loadString("assets/tmp_phone_io/prediction.json");
      final jsonResult = jsonDecode(data); //latest Dart
      PredictionAutogenerated predictions =
          PredictionAutogenerated.fromJson(jsonResult);
      return predictions;
    }

    return Container(
      margin: const EdgeInsets.all(8),
      child: FutureBuilder(
          future: _readPhonePredictionIOFiles(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.done) {
              final PredictionAutogenerated predictionIOData = snapshot.data;
              return FutureBuilder(
                future: readPhoneWVCIOFiles(context),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.done) {
                    final List<List<dynamic>> wVCIOData = snapshot.data;
                    print('wVCIOData:,$wVCIOData');
                    return SingleChildScrollView(
                      child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Container(
                              margin: EdgeInsets.fromLTRB(0, 0, 0, 5),
                              // padding: const EdgeInsets.fromLTRB(1, 8, 8, 8),
                              child: Text(
                                'Mood prediction for today with prediction interval:',
                                style: TextStyle(
                                    fontSize: 15.5,
                                    fontWeight: FontWeight.w500),
                              ),
                            ),
                            biDirectionalGanttChart(
                                predictionIOData.scaleBounds,
                                context,
                                wVCIOData),
                            SizedBox(height: 3),
                            predictionWidget(predictionIOData),
                            numericScale(predictionIOData.scaleBounds),
                            showGanttExplanation(context),
                          ]),
                    );
                  } else {
                    return CircularProgressIndicator();
                  }
                },
              );
            } else {
              return Container(
                child: CircularProgressIndicator(),
              );
            }
          }),
    );
  }
}

Widget triangleScatterPlot(context, doseName, wVCIOData, scaleBounds) {
  print('wVCIOData:$wVCIOData');

  /// header: [0]featureName [1]contribution	[2]weight
  /// [3]value_today_not_normalized	[4]value_today_normalized
  /// [5]extrema[max,min]
  const double height = 407;
  const double width = 365;

  final double scalingFactorHeight = height / (scaleBounds[1] - scaleBounds[0]);

  final double dose = wVCIOData[4] * width * 0.3;
  print('dose:$dose');
  final double response = wVCIOData[1] * scalingFactorHeight; //height*-0.1;
  Color triangleColor = kindaGreen;
  if (response < 0) {
    triangleColor = kindaRed;
  }
  return Stack(children: [
    SizedBox(
      height: 450, // height constraint
      child: SizedBox.expand(
        /// scatter plot
        child: futureScatterPlot('Mood', wVCIOData[0],false),
      ),
    ),
    Column(children: [
      SizedBox(height: 7),

      Row(children: [
        SizedBox(width: 30),
        Container(
            child: Stack(children: [
              Container(color: Colors.grey.withOpacity(0.1)),
              ClipPath(
                child: Container(
                  width: MediaQuery.of(context).size.width,
                  color: triangleColor.withOpacity(0.5),
                ),
                clipper:
                    TriangleClipPath(height / 2, width / 2, dose, response),
              )
            ]),
            height: height,
            width: width),
        // RotatedBox(
        //     quarterTurns: 1,
        //     child: Text('Mood Contribution')),
      ]),
      // Text('Today\'s-Average Humidity')
    ])
  ]);
}

class TriangleClipPath extends CustomClipper<Path> {
  final double heightHalf;
  final double widthHalf;
  final double dose;
  final double response;

  TriangleClipPath(this.heightHalf, this.widthHalf, this.dose, this.response);

  @override
  Path getClip(Size size) {
    Path path = Path();
    path.lineTo(229, 142); //start in middle dosage; mean response
    path.lineTo(dose + 229, 142); //right/left
    path.lineTo(dose + 229, -response + 229); //up/down
    path.lineTo(229, 142); //end in middle
    return path;
  }

  @override
  bool shouldReclip(CustomClipper<Path> oldClipper) => false;
}
